# 二、RTOS简介

# RTOS基础

- 为什么需要实时操作系统？
- 特点与优势？

## RTOS内核架构

- 调度器、上下文切换等
- C 库、中断和无限循环对嵌入式编程足够好吗？
- 操作系统不是太占用内存吗？
- 使用操作系统是嵌入式编程的“矫枉过正”吗？
- 能用 Arduino 做到这一点吗？
- 为什么需要多任务处理？

## 主流的裸机开发程序流

- 主循环 - 循环执行
- 硬件初始化功能
- 函数——可调用的代码块
- 子程序（不是一个函数，而是一个代码单位）
- 中断服务程序

### C语言库循环执行模型

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled.png)

**缺点**

● 延迟——无法保证功能完成时间
● 可靠性——无法保证功能开始
● 优先级——难以管理
● 不可预测——难以控制 ISR 的执行
● 受限 ———无法轻松扩展功能
● 不灵活 ——– 固定设置
● 可移植性——移植到其他平台过于繁琐

**解决方法**

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%201.png)

**循环执行  VS  RTOS**

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%202.png)

# 实时操作系统的优势

- **技术性**
 并发执行、多任务处理、 线程\进程的优先级、执行（任务） 中断处理、变量/函数的同步
- **硬件抽象层 (HAL)**
- **功能可扩展性**
- **平台独立性**
- **资源管理**
- **模拟器\调试工具**
- **结构**
• 代码风格标准和结构
• 代码模块化
• 代码复用
• 用户在线社区（即帮助！）
• 维护和改进
• 许可 – GPL\MIT\Royalty Free

**RTOS——“实时意味着现在！”**

- 设计用于在资源受限的情况下运行设备
- 满足硬件特定功能，即能源管理
- 自主运行
- 工业控制应用
- 易于硬件外设接口
- 广泛的可配置选项

**操作系统**

- 专为在资源丰富的设备上运行而设计
- 专为互操作性而设计（plug and play）
- 专为高级用户界面而设计

**RTOS 提供**

- 并发任务（线程\进程的执行）
- 多任务处理
- 数据/参数（共享队列）
- 优先级
- 同步（信号量）
- 硬件抽象层 (HAL)
- 时间管理
- 资源管理

**高级功能**

- 嵌入式网络堆栈
- 文件系统

## 1、RTOS架构

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%203.png)

**注：**

**Synchronisation         同步**

## 2、RTOS内核

**Kernel：实时操作系统处理核心**

**操作**

- 并发和多任务执行
- 中断请求
- 资源和时间管理

**内容（Contains）**

- 实时调度器
- 上下文（Context）切换
- 资源管理器
- 硬件接口

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%204.png)

## 3、RTOS调度器

- 调度程序：确定**何时**一个**任务**或**中断请求**可以**执行**
- 多任务处理：允许多于一项任务执行
- 并发执行：允许多于一项任务同时执行

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%205.png)

**任务调度器的特点**

**优先抢先**

• 允许在执行时中断任务

• 使用任务的优先级来确定日程

**先进先出**

• “队列”中的第一个任务执行

**最短剩余时间**

• 执行运行时间最短的任务

**轮循（Round-robin）**

• 不按顺序执行每个任务

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%206.png)

先发制人任务示例

使用事件/中断进行调度

**操作**

- 挂起（Suspend 暂停）内核（Kernel）
- 挂起并换出（Swap out）任务
- 任务中的恢复和交换
- 判断任务是否使用了硬件资源，采取适当的阻塞\锁定动作
- 执行任务

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%207.png)

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%208.png)

1. 任务 1 正在执行
2. 内核挂起（换出）任务1
3. 恢复任务 2
4. 当任务 2 执行时，它会锁定一个处理器外设（例如 SPI1）拥有独家访问权
5. 内核挂起任务2
6. 恢复任务 3
7. 任务 3 尝试访问相同的处理器外设（例如 SPI1），发现它锁定了，任务3 无法继续，因此会自行暂停
8. 内核恢复任务1
9. 下一次执行任务 2 时，它会完成处理器外设并解锁它
10. 下一次执行任务 3 时，它发现它现在可以访问处理器外围设备，这次执行直到被内核挂起

## 4、RTOS上下文切换（Context Switching）

注：Context(上下文)解释，当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中断服务结束时能恢复被中断进程的执行。
[https://blog.csdn.net/HandsomeHong/article/details/107868926](https://blog.csdn.net/HandsomeHong/article/details/107868926)

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%209.png)

**Instruction Register 指令寄存器**

- 任务不知道何时会被内核挂起（换出或切换出）或恢复（换入或切换）。
- 为防止出错，任务恢复后有一个“上下文”与紧接其之前的相同暂停。
- 内核在挂起时保存任务的上下文。
- 恢复时——执行之前的内核恢复任务保存的上下文。

***执行任务的上下文示例：***

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%2010.png)

```c
//上下文保存（Saving）函数的伪代码
portSAVE_CONTEXT() {
asm volatile (
push r0
in r0, __SREG__
//保存寄存器的值
/**********************/
cli
push r0
push r1
clr r1
push r2
push r3
/**********************/
:::::
//保存堆栈
/**********************/
push r31
lds r26,pxCurrentTCB
lds r27,pxCurrentTCB + 1
in r0, __SP_L__
/**********************/

st x+, r0
in r0, __SP_H__
st x+, r0
)
}

//上下文恢复(Restoring)函数的伪代码
portRESTORE_CONTEXT() {
asm volatile (
lds r26, pxCurrentTCB
lds r27,
//恢复堆栈
/**********************/
pxCurrentTCB + 1
ld r28, x+
out __SP_L__, r28
ld r29, x+
out __SP_H__, r29
pop r31
pop r30
/**********************/
::::
//恢复寄存器的值
/**********************/
pop r1
pop r0
out __SREG__, r0
pop r0
/**********************/
)
}
```

**注：**

（1）、LDS REG,OPRE;REG是一个16位寄存器,OPRD是一个存储器操作数,为双字项,高16位送入DS,低16位送入REG

（2）、CLI 禁止中断发生，STL允许中断发生，只能在内核模式下执行，不可以在用户模式下执行；而且在内核模式下执行时，应该尽可能快的恢复中断，因为CLI会禁用硬件中断，若长时间禁止中断会影响其他动作的执行（如移动鼠标等等），系统就会变得不稳定。

## 5、RTOS资源管理（Resource Management）

● 资源管理：管理内存和其他硬件外围资源。

● 嵌入式平台通常“资源贫乏”。

● 标准 C 库 malloc() 和 free() 函数有时可能被使用，而且

- 在嵌入式系统上并非总是可用
- 占用宝贵的代码空间
- 不是线程安全的
- 不确定性（执行该函数**(Function)**所花费的时间量将因调用而异）

注：

```c
extern void *malloc(unsigned int num_bytes);‘
//意为分配长度为num_bytes字节的内存块
```

malloc()时动态内存分配函数，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址

```c
free(void*ptr);
//释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，它指向被释放区域的首地址。
```

free() 释放malloc(或calloc、realloc)函数给指针变量分配的内存空间

**内存堆分配（Memory Heap Allocation）：**

![Untitled](%E4%BA%8C%E3%80%81RTOS%E7%AE%80%E4%BB%8B%202e749076f78246d2a0e6d7e286135da7/Untitled%2011.png)

**注：**

Allocation 分配

Heap 堆

**不同的内存分配算法：**

使用安全线程的 malloc() 和 free() 函数。

**最好的拟合**

- 分配最小的块内存

**最差的拟合**

- 分配最大的内存块

**第一次拟合**

- 找到第一个适合的内存块

**下一次适合**

- 第一次拟合的变体，找到下一个适合的内存块。

# **总结**（**Summary）**

1、**实时操作系统基础**

- RTOS 功能：任务、同步、共享、优先级、HAL 等

2、**实时操作系统内核**

- RTOS 的核心
- 执行调度、上下文切换、资源管理

3、**调度**

- 确定任务何时可以执行

4、**上下文切换**

- 在没有错误情况下，允许暂停和恢复任务

5、**资源管理**

- RTOS 的内存分配和解除分配元素